from pydantic import (
    BaseModel,
    validator,
    ValidationError,
    field_validator,
    root_validator,
)
from pydantic.error_wrappers import ValidationError

from typing import Optional
from flask import g
from sqlalchemy.orm import Session

from ..database.models import User, TimeTracker
from datetime import datetime


class UserRequestSchema(BaseModel):
    name: str
    email: str
    age: Optional[int]
    password: str
    is_admin: bool

    class Config:
        orm_mode = True
        from_attributes = True  # Enable from_orm support

    @field_validator("email")
    def check_email_exists(cls, value):
        # Access the database session from Flask's `g` object

        # Check if the email already exists in the database
        existing_user = (
            g.database.session.query(User).filter(User.email == value).first()
        )
        if existing_user:
            raise ValueError("Email already exists")

        return value


class UserResponseSchema(BaseModel):
    id: Optional[int] = None  # ID is auto-generated by the database
    name: str
    email: str
    age: Optional[int]

    class Config:
        orm_mode = True
        from_attributes = True  # Enable from_orm support


from typing import Generic, TypeVar, List
from pydantic import BaseModel

# Define a generic type variable
T = TypeVar("T")


class GenericListSchema(BaseModel, Generic[T]):
    items: List[T]


class UserListSchema(BaseModel):
    data: list[UserResponseSchema]


class PaginationSchema(BaseModel, Generic[T]):
    items: List[T]
    page: int
    page_size: int
    total_pages: int
    total_items: int


class LoginSchema(BaseModel):
    email: str
    password: str


class TimeTrackerRequestSchema(BaseModel):
    task_description: str
    start_date: Optional[str] = ""
    end_date: Optional[str] = ""

    class Config:
        orm_mode = True
        from_attributes = True  # Enable from_orm support

    @root_validator(pre=True)
    def validate_all_fields(cls, values):
        """
        Validates all fields in the model before they are saved or used.
        """
        # Loop through each field and validate

        active_time_tracker = TimeTracker.query.filter(
            TimeTracker.end_date == None
        ).first()
        if active_time_tracker:
            raise ValueError("Time is being tracked. Please finish the ongoing task.")

        return values


class TimeTrackerResponseSchema(BaseModel):
    task_description: str
    start_date: Optional[str] = ""
    end_date: Optional[str] = ""
    user: UserResponseSchema

    class Config:
        orm_mode = True
        from_attributes = True  # Enable from_orm support


class EventSchema(BaseModel):
    name: str
    date: str
    venue: str
    price: float
    total_tickets: int

    class Config:
        orm_mode = True
        from_attributes = True  # Enable from_orm support


class EventResponseSchema(BaseModel):
    id: int
    name: str
    date: str
    venue: str
    price: float
    total_tickets: int

    class Config:
        orm_mode = True
        from_attributes = True  # Enable from_orm support

    @field_validator("date", mode="before")
    def validate_date(cls, value):
        if isinstance(value, datetime):
            # Convert datetime to ISO 8601 string format
            return value.isoformat()
        return value


class TicketShema(BaseModel):
    id: int

    class Config:
        orm_mode = True
        from_attributes = True  # Enable from_orm support


class OrderResposeSchema(BaseModel):
    id: int
    status: str

    class Config:
        orm_mode = True
        from_attributes = True  # Enable from_orm support
